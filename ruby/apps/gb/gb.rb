require("targets.rb")
require("gubg/graph")
require("gubg/options")

options = parseOptions(name: "Generic build utility", author: "Geert Fannes", version: "0.1") do |parser, options|
    parser.on("-e", "--executable SOURCE", "Produce executable from SOURCE"){|filename|options[:executable] = filename}
end
$verbose = options[:verbose]

location = Location.new
configs = Configs.new
trees = Trees.new
cppFiles = CppFiles.new
hppFiles = HppFiles.new
compileSettings = CompileSettings.new
linkSettings = LinkSettings.new
objectFiles = ObjectFiles.new
executables = Executables.new

graph = Graph.new
graph.addEdge(configs, location)
graph.addEdge(trees, configs)
graph.addEdge(hppFiles, trees)
graph.addEdge(hppFiles, cppFiles)
graph.addEdge(cppFiles, configs)
graph.addEdge(cppFiles, trees)
graph.addEdge(cppFiles, hppFiles)
graph.addEdge(compileSettings, configs)
graph.addEdge(compileSettings, trees)
graph.addEdge(compileSettings, hppFiles)
graph.addEdge(compileSettings, cppFiles)
graph.addEdge(linkSettings, configs)
graph.addEdge(objectFiles, compileSettings)
graph.addEdge(objectFiles, cppFiles)
graph.addEdge(executables, linkSettings)
graph.addEdge(executables, objectFiles)

if options[:executable]
    filename = File.expand_path(options[:executable])
    location.set(File.dirname(filename))
    cppFiles.starter = filename
end

def printTarget(target)
    puts("\t#{target.class} (#{target.state}): #{target.explanation}")
end

cycle = -1
loop do
    cycle += 1
    break if cycle > 10
    puts("Entering cycle #{cycle}")
    #Collect all unfinished targets
    unfinishedTargets = graph.vertices.reject{|v|v.state == :generated}
    break if unfinishedTargets.empty?

    #Collect all targets that can be generated directly, i.e., all dependent targets are generated
    generatableTargets = unfinishedTargets.select{|t|graph.outVertices(t).all?{|v|v.state == :generated}}
    if !generatableTargets.empty?
        puts("\tThe following targets are generatable #{generatableTargets}")
        generatableTargets.each do |t|
            t.generate(graph.outVertices(t))
            printTarget(t)
        end
        notGeneratedTargets = generatableTargets.select{|t|t.state != :generated}
        if !notGeneratedTargets.empty?
            finalize("I expected all targets to be generated by now, but these are not: #{notGeneratedTargets.map{|ngt|ngt.class}}", :error)
        end
        next
    end

    #Collect all progressible targets
    progressibleTargets = unfinishedTargets.select{|t|t.progressible?(graph.outVertices(t))}
    if !progressibleTargets.empty?
        if progressibleTargets.all?{|t|t.state == :halted}
            #All targets are halted, we give them a chance to become generated, else we stop
            progressibleTargets.each do |t|
                t.generate(graph.outVertices(t))
                printTarget(t)
            end
            finalize("No more progress could be made, halted targets remain (#{progressibleTargets.map{|pt|pt.class}}", :error) if progressibleTargets.all?{|t|t.state == :halted}
        elsif progressibleTargets.any?{|t|t.state == :error}
            progressibleTargets.each do |t|
                printTarget(t) if t.state == :error
            end
            finalize("Processing progressible targets resulted in an error", :error)
        else
            puts("\tThe following targets are generatable #{progressibleTargets}")
            progressibleTargets.each do |t|
                t.generate(graph.outVertices(t))
                printTarget(t)
            end
        end
        next
    end

    finalize("Unable to find a target to work on", :error)
end

puts("#{graph}")
