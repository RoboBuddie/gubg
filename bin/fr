#!/usr/bin/env ruby

require("gubg/utils")

arguments = ARGV.dup
action = :print
if ARGV.length == 0
  puts(%Q@fr [option] <pattern>
\t-i\t\tSearch case-insensitive
\t-o\t\tOpen the files in emacs that match the <pattern>
\t-r string\tShow how the <pattern> would be replaced, but do not actually replace
\t-R string\tSame as -r, but now <pattern> is actually replaced
Geert Fannes.
@)
  exit
end

caseInsensitive = nil
action = :print
files2Open = nil
replace = nil
newValue = nil

arguments = ARGV.dup
foundOption = nil
begin
  foundOption = true
  case arguments[0]
  when "-i"
    arguments.shift
    caseInsensitive = true
  when "-o"
    arguments.shift
    action = :open
    files2Open = []
  when "-r"
    arguments.shift
    action = :replace
    replace = false
    newValue = arguments.shift
  when "-R"
    arguments.shift
    action = :replace
    replace = true
    newValue = arguments.shift
  else
    foundOption = false
  end
end while foundOption

lookFor = Regexp.new(arguments[0], caseInsensitive)

recursor = Proc.new do |dir|
  case File.basename(dir)
  when /^\./
    false
  when /^(html)|(docs)|(data)$/
    false
  else
    true
  end
end

unwantedExtensions = %w[a o dll pem der b64 cnf txt bin sh py java jar cloak.c cloak.cpp]
str = unwantedExtensions.collect{|ext|"(\\.#{ext})"}.join("|")
reUnwantedExtensions = Regexp.compile("(#{str})"+'$')

wantedExtensions = %w[c h cpp hpp d rb S asm]
str = wantedExtensions.collect{|ext|"(\\.#{ext})"}.join("|")
reWantedExtensions = Regexp.compile("(#{str})"+'$')

pwd = Dir.pwd+'/'
Dir.each("./",recursor) do |dir, fn|
  check = true
  case fn
  when reUnwantedExtensions
    check = false
  when reWantedExtensions
  when /^Makefile/
  else
    check = false
  end
  if check
    str = String.load(File.expand_path(fn, dir))
    if str.nil?
      puts("Failed to load #{File.expand_path(fn, dir)}")
    elsif str[lookFor]
      path = File.expand_path(fn, dir)
      path[pwd] = ''
      lines = str.split("\n")
      lines.each_with_index do |line, ix|
        if line[lookFor]
          case action
          when :print
            puts(path+":#{ix+1} #{line}")
          when :open
            files2Open << path+":#{ix+1}"
          when :replace
            print(path+":#{ix+1} (#{line}) -> ")
            line[lookFor] = newValue
            puts("(#{line})")
          end
        end
      end
      if action == :replace and replace
        lines.join("\n").export(File.expand_path(fn, dir))
      end
    end
  end
  nil
end

case action
when :open
  command = "e " + files2Open.join(" ")
  system(command)
end
